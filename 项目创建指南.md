# 从零创建 RAG 代码生成项目 - 完整指南

## 前置准备

### 1. 环境要求

- Node.js >= 18
- pnpm >= 9 (或 npm/yarn)
- PostgreSQL 数据库（支持 pgvector 扩展）
- OpenAI API Key（或兼容的 API）

### 2. 数据库准备

- 创建 PostgreSQL 数据库
- 安装 pgvector 扩展：
  ```sql
  CREATE EXTENSION IF NOT EXISTS vector;
  ```

---

## 步骤 1: 初始化 Next.js 项目

```bash
# 使用 Next.js 官方脚手架创建项目
pnpm create next-app@latest private-component-codegen

# 选择配置：
# - TypeScript: Yes
# - ESLint: Yes
# - Tailwind CSS: Yes
# - App Router: Yes
# - src/ directory: No
# - Import alias: @/*
```

---

## 步骤 2: 安装核心依赖

```bash
# Storybook 相关
pnpm add -D @storybook/react @storybook/react-vite @storybook/addon-essentials @storybook/addon-interactions @storybook/addon-links @storybook/blocks @storybook/test storybook

# AI SDK 相关
pnpm add ai @ai-sdk/openai

# 数据库相关
pnpm add drizzle-orm drizzle-zod postgres pg
pnpm add -D drizzle-kit

# UI 组件库
pnpm add antd @ant-design/icons @ant-design/nextjs-registry
pnpm add @emotion/react @emotion/styled @emotion/css @emotion/cache
pnpm add styled-components

# 工具库
pnpm add zod @t3-oss/env-nextjs nanoid lodash
pnpm add react-markdown react-syntax-highlighter
pnpm add remark-gfm remark-breaks remark-math rehype-katex

# 绘图组件（可选）
pnpm add @tldraw/tldraw

# 环境变量管理
pnpm add -D dotenv tsx
```

---

## 步骤 3: 配置 TypeScript

创建/更新 `tsconfig.json`：

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

---

## 步骤 4: 配置环境变量

### 4.1 创建 `.env` 文件

```bash
# 数据库连接字符串
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# 嵌入模型
EMBEDDING=text-embedding-ada-002

# 大模型 API Key
AI_KEY=sk-xxx

# 大模型 API Base URL
AI_BASE_URL=https://api.openai.com/v1

# 大模型名称
MODEL=gpt-4o
```

### 4.2 创建环境变量验证文件

创建 `lib/env.mjs`：

```javascript
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";
import "dotenv/config";

export const env = createEnv({
  server: {
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),
    DATABASE_URL: z.string().min(1),
    HTTP_AGENT: z.string().optional(),
    EMBEDDING: z.string().min(1),
    AI_KEY: z.string().min(1),
    AI_BASE_URL: z.string().min(1),
    MODEL: z.string().min(1),
  },
  client: {},
  experimental__runtimeEnv: {},
});
```

---

## 步骤 5: 配置数据库

### 5.1 创建 Drizzle 配置文件

创建 `drizzle.config.ts`：

```typescript
import type { Config } from "drizzle-kit";
import { env } from "@/lib/env.mjs";

export default {
  schema: "./lib/db/**/*/schema.ts",
  dialect: "postgresql",
  out: "./lib/db/migrations",
  dbCredentials: {
    url: env.DATABASE_URL,
  },
} satisfies Config;
```

### 5.2 创建数据库连接

创建 `lib/db/index.ts`：

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { env } from "@/lib/env.mjs";

const connectionString = env.DATABASE_URL;
const client = postgres(connectionString);

export const db = drizzle(client);
```

### 5.3 创建数据库 Schema

创建 `lib/db/vercelai/schema.ts`：

```typescript
import { index, pgTable, text, varchar, vector } from "drizzle-orm/pg-core";
import { nanoid } from "nanoid";

export const vercelAiEmbeddings = pgTable(
  "vercel_ai_embeddings",
  {
    id: varchar("id", { length: 191 })
      .primaryKey()
      .$defaultFn(() => nanoid()),
    content: text("content").notNull(),
    embedding: vector("embedding", { dimensions: 1536 }).notNull(),
  },
  (t) => ({
    vercelaiEmbeddingIndex: index("vercelai_embedding_index").using(
      "hnsw",
      t.embedding.op("vector_cosine_ops")
    ),
  })
);
```

### 5.4 创建数据库操作文件

创建 `lib/db/vercelai/actions.ts`：

```typescript
"use server";

import { db } from "@/lib/db";
import { vercelAiEmbeddings } from "./schema";

export async function saveEmbeddings(
  embeddings: Array<{ embedding: number[]; content: string }>
) {
  try {
    const result = await db.insert(vercelAiEmbeddings).values(
      embeddings.map(({ embedding, content }) => ({
        content,
        embedding,
      }))
    );

    return {
      success: true,
      data: result,
    };
  } catch (error) {
    console.error("保存 embeddings 时出错:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "未知错误",
    };
  }
}
```

创建 `lib/db/vercelai/selector.ts`：

```typescript
"use server";

import { sql } from "drizzle-orm";
import { db } from "@/lib/db";
import { vercelAiEmbeddings } from "./schema";

export interface SimilaritySearchResult {
  content: string;
  similarity: number;
}

export async function similaritySearch(
  embedding: number[],
  threshold: number = 0.7,
  limit: number = 5
): Promise<SimilaritySearchResult[]> {
  if (!embedding || embedding.length === 0) {
    throw new Error("查询向量不能为空");
  }

  if (threshold < 0 || threshold > 1) {
    throw new Error("相似度阈值必须在 0 到 1 之间");
  }

  if (limit < 1) {
    throw new Error("返回数量必须大于 0");
  }

  try {
    const vectorArray = `array[${embedding.join(",")}]::vector`;

    const results = await db
      .select({
        content: vercelAiEmbeddings.content,
        similarity: sql<number>`1 - (${
          vercelAiEmbeddings.embedding
        } <=> ${sql.raw(vectorArray)})`.as("similarity"),
      })
      .from(vercelAiEmbeddings)
      .where(
        sql`1 - (${vercelAiEmbeddings.embedding} <=> ${sql.raw(
          vectorArray
        )}) >= ${threshold}`
      )
      .orderBy(sql`similarity DESC`)
      .limit(limit);

    return results;
  } catch (error) {
    console.error("向量相似度搜索时出错:", error);
    throw error;
  }
}
```

### 5.5 创建数据库迁移脚本

创建 `lib/db/migrate.ts`：

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import { migrate } from "drizzle-orm/postgres-js/migrator";
import postgres from "postgres";
import { env } from "@/lib/env.mjs";

const connectionString = env.DATABASE_URL;
const sql = postgres(connectionString, { max: 1 });
const db = drizzle(sql);

async function main() {
  console.log("开始数据库迁移...");
  await migrate(db, { migrationsFolder: "./lib/db/migrations" });
  console.log("数据库迁移完成！");
  await sql.end();
}

main();
```

### 5.6 生成并运行迁移

```bash
# 生成迁移文件
pnpm db:generate

# 运行迁移
pnpm db:migrate
```

---

## 步骤 6: 创建 Embedding 功能

### 6.1 创建 Embedding 工具文件

创建 `app/api/vercelai/embedding.ts`：

```typescript
import { embed } from "ai";
import { createOpenAI } from "@ai-sdk/openai";
import { env } from "@/lib/env.mjs";
import {
  similaritySearch,
  SimilaritySearchResult,
} from "@/lib/db/vercelai/selector";

export interface EmbeddingResult {
  content: string;
  embedding: number[];
}

const openai = createOpenAI({
  apiKey: env.AI_KEY,
  baseURL: env.AI_BASE_URL,
});

export async function generateEmbeddings(
  text: string,
  separator: string = "-------split line-------"
): Promise<EmbeddingResult[]> {
  const textChunks = text
    .split(separator)
    .filter((chunk) => chunk.trim().length > 0);

  if (textChunks.length === 0) {
    return [];
  }

  const embeddingPromises = textChunks.map(async (chunk) => {
    const embeddingResponse = await embed({
      model: openai.embedding(env.EMBEDDING),
      value: chunk,
    });
    return embeddingResponse.embedding;
  });

  const embeddings = await Promise.all(embeddingPromises);

  const results: EmbeddingResult[] = textChunks.map((content, index) => ({
    content,
    embedding: embeddings[index],
  }));

  return results;
}

export async function generateSingleEmbedding(text: string): Promise<number[]> {
  const embeddingResponse = await embed({
    model: openai.embedding(env.EMBEDDING),
    value: text,
  });
  return embeddingResponse.embedding;
}

export async function retrieveRecall(
  text: string,
  threshold: number = 0.5,
  limit: number = 5
): Promise<SimilaritySearchResult[]> {
  const embedding = await generateSingleEmbedding(text);
  const results = await similaritySearch(embedding, threshold, limit);
  return results;
}
```

### 6.2 创建 Embedding 初始化脚本

创建 `app/api/vercelai/embedDocs.ts`：

```typescript
import { readFileSync } from "fs";
import { join } from "path";
import { generateEmbeddings } from "./embedding";
import { saveEmbeddings } from "@/lib/db/vercelai/actions";

async function main() {
  // 读取文档内容（根据实际情况调整路径）
  const docsPath = join(process.cwd(), "ai-docs", "basic-components.txt");
  const content = readFileSync(docsPath, "utf-8");

  console.log("开始生成 embeddings...");
  const embeddings = await generateEmbeddings(content);

  console.log(`生成了 ${embeddings.length} 个 embeddings`);

  console.log("开始保存到数据库...");
  const result = await saveEmbeddings(embeddings);

  if (result.success) {
    console.log("✅ Embeddings 保存成功！");
  } else {
    console.error("❌ Embeddings 保存失败:", result.error);
  }
}

main();
```

---

## 步骤 7: 创建系统提示词

创建 `lib/prompt.ts`：

```typescript
export const getSystemPrompt = (reference?: string) => `
# Role: 前端业务组件开发专家

## Profile
- author: lv
- version: 0.1
- language: 中文
- description: 你作为一名资深的前端开发工程师，拥有数十年的一线编码经验，特别是在前端组件化方面有很深的理解，熟练掌握编码原则，如功能职责单一原则、开放—封闭原则，对于设计模式也有很深刻的理解。

## Goals
- 能够清楚地理解用户提出的业务组件需求.
- 根据用户的描述生成完整的符合代码规范的业务组件代码。

## Constraints
- 业务组件中用到的所有组件都来源于 \`import {  } from "@private-basic-components"\` 组件库。
- 必须遵循知识库<API> </API>中组件的 props 来实现业务组件

## Workflows
第一步：结合用户需求理解我提供给你的\`@private-basic-components\`组件知识库数据。
第二步：请根据用户的需求以及我提供的知识库数据，生成对应的业务组件代码，业务组件的规范模版如下：

组件包含 4 类文件，对应的文件名称和规则如下:

    1、index.ts（对外导出组件）
    2、interface.ts（类型定义）
    3、[组件名].stories.tsx（Storybook 文档）
    4、[组件名].tsx（组件实现，使用 tailwindcss）

## Initialization
作为前端业务组件开发专家，你十分清晰你的[Goals]，同时时刻记住[Constraints], 你将用清晰和精确的语言与用户对话，并按照[Workflows]逐步思考，逐步进行回答，竭诚为用户提供代码生成服务。

${
  reference
    ? `------

使用 <Reference></Reference> 标记中的内容作为本次对话的参考:

<Reference>
${reference}
</Reference>
`
    : ""
}
`;
```

---

## 步骤 8: 创建 API 路由

### 8.1 创建类型定义

创建 `app/api/vercelai/types.ts`：

```typescript
import { CoreMessage } from "ai";

export interface OpenAIRequest {
  messages: CoreMessage[];
}
```

### 8.2 创建主 API 路由

创建 `app/api/vercelai/route.ts`：

```typescript
import { NextRequest } from "next/server";
import { streamText } from "ai";
import { createOpenAI } from "@ai-sdk/openai";
import { env } from "@/lib/env.mjs";
import { retrieveRecall } from "./embedding";
import { getSystemPrompt } from "@/lib/prompt";
import { OpenAIRequest } from "./types";

const openai = createOpenAI({
  apiKey: env.AI_KEY,
  baseURL: env.AI_BASE_URL,
});

export async function POST(request: NextRequest) {
  try {
    const body: OpenAIRequest = await request.json();
    const { messages } = body;

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return new Response(JSON.stringify({ error: "消息数组不能为空" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const lastMessage = messages[messages.length - 1];
    let lastUserMessageText: string | null = null;

    if (lastMessage.role === "user" && lastMessage.content) {
      if (typeof lastMessage.content === "string") {
        lastUserMessageText = lastMessage.content;
      } else if (Array.isArray(lastMessage.content)) {
        const textParts = lastMessage.content
          .filter((part) => part.type === "text")
          .map((part) => (part as { text: string }).text)
          .join(" ");
        if (textParts) {
          lastUserMessageText = textParts;
        }
      }
    }

    let referenceContent = "";
    if (lastUserMessageText) {
      try {
        const searchResults = await retrieveRecall(lastUserMessageText, 0.5, 5);
        if (searchResults && searchResults.length > 0) {
          referenceContent = searchResults
            .map((result) => result.content)
            .join("\n\n");
        }
      } catch (error) {
        console.error("向量检索失败:", error);
      }
    }

    const systemPrompt = getSystemPrompt(referenceContent || undefined);

    const messagesWithSystem = [
      {
        role: "system" as const,
        content: systemPrompt,
      },
      ...messages,
    ];

    const result = await streamText({
      model: openai(env.MODEL),
      messages: messagesWithSystem,
      temperature: 0.7,
    });

    const headers: Record<string, string> = {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
      "X-Accel-Buffering": "no",
    };

    if (referenceContent) {
      headers["X-RAG-Content"] =
        Buffer.from(referenceContent).toString("base64");
    }

    return result.toDataStreamResponse({
      headers,
    });
  } catch (error) {
    console.error("API 路由错误:", error);
    return new Response(
      JSON.stringify({
        error: "处理请求时发生错误",
        message: error instanceof Error ? error.message : String(error),
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
}
```

---

## 步骤 9: 创建前端组件

### 9.1 创建消息接口

创建 `app/components/ChatMessages/interface.ts`：

```typescript
export interface RAGDocument {
  id: string;
  content: string;
  score?: number;
}

export interface Message {
  id: string;
  role: "user" | "assistant";
  content:
    | string
    | Array<{
        type: "text" | "image_url";
        text?: string;
        image_url?: { url: string };
      }>;
  ragDocs?: RAGDocument[];
}

export interface ChatMessagesProps {
  messages: Message[];
  input: string;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isLoading: boolean;
  messageImgUrl: string;
  setMessagesImgUrl: (url: string) => void;
  onRetry?: (messageId: string) => void;
}
```

### 9.2 创建 ChatInput 组件

创建 `app/components/ChatInput/ChatInput.tsx`（参考现有实现）

### 9.3 创建 ChatMessages 组件

创建 `app/components/ChatMessages/ChatMessages.tsx`（参考现有实现）

### 9.4 创建其他辅助组件

- `AssistantMessage.tsx` - AI 消息展示
- `UserMessage.tsx` - 用户消息展示
- `RAGDocsShow.tsx` - RAG 文档展示
- `Markdown.tsx` - Markdown 渲染

---

## 步骤 10: 创建主页面

创建 `app/vercel-ai/index.tsx`（参考现有实现）

更新 `app/page.tsx` 作为入口页面

---

## 步骤 11: 配置 Next.js

更新 `next.config.mjs`：

```javascript
const nextConfig = {
  compiler: {
    styledComponents: true,
  },
};

export default nextConfig;
```

---

## 步骤 12: 配置 Tailwind CSS

确保 `tailwind.config.ts` 配置正确：

```typescript
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
```

---

## 步骤 13: 配置 Ant Design

创建 `app/layout.tsx`：

```typescript
import { AntdRegistry } from "@ant-design/nextjs-registry";
import "./globals.css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh">
      <body>
        <AntdRegistry>{children}</AntdRegistry>
      </body>
    </html>
  );
}
```

---

## 步骤 14: 更新 package.json 脚本

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "tsx lib/db/migrate.ts",
    "db:push": "drizzle-kit push",
    "vercelai:embedDocs": "tsx app/api/vercelai/embedDocs.ts"
  }
}
```

---

## 步骤 15: 初始化数据

### 15.1 准备知识库文档

创建 `ai-docs/basic-components.txt`，包含组件库文档（使用 `-------split line-------` 分隔不同组件）

### 15.2 生成 Embeddings

```bash
pnpm vercelai:embedDocs
```

---

## 步骤 16: 启动项目

```bash
# 开发模式
pnpm dev

# 访问 http://localhost:3000
```

---

## 关键检查点

✅ 数据库连接正常  
✅ pgvector 扩展已安装  
✅ 环境变量配置正确  
✅ 数据库迁移成功  
✅ Embeddings 已生成并保存  
✅ API 路由正常工作  
✅ 前端组件正常渲染

---

## 常见问题

### 1. pgvector 扩展安装失败

```sql
-- 确保 PostgreSQL 版本 >= 11
-- 使用管理员权限执行
CREATE EXTENSION vector;
```

### 2. 数据库连接失败

- 检查 `DATABASE_URL` 格式
- 确保数据库服务运行中
- 检查防火墙设置

### 3. Embedding 生成失败

- 检查 `AI_KEY` 和 `AI_BASE_URL` 配置
- 确认 API 额度充足

### 4. 向量搜索性能慢

- 确保 HNSW 索引已创建
- 调整相似度阈值和返回数量

---

## 后续优化建议

1. **添加错误处理**：完善错误边界和用户提示
2. **性能优化**：添加缓存、优化向量搜索
3. **UI 优化**：添加加载状态、动画效果
4. **功能扩展**：支持多轮对话上下文、代码导出等
5. **测试**：添加单元测试和集成测试
6. **文档**：完善 API 文档和使用说明
